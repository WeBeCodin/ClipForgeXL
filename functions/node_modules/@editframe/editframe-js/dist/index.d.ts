import { Blob } from 'node:buffer';
import { Readable } from 'stream';
import { Readable as Readable$1 } from 'node:stream';
import FormData from 'form-data';
import { JsonValue } from 'type-fest';
import * as ts_mixer_dist_types_types from 'ts-mixer/dist/types/types';

declare enum DimensionsKey {
    height = "height",
    width = "width"
}
type Dimensions = {
    [DimensionsKey.height]: number;
    [DimensionsKey.width]: number;
};

declare enum AudioKey {
    volume = "volume",
    normalize = "normalize"
}
type AudioOptions = {
    [AudioKey.volume]?: number;
    [AudioKey.normalize]?: boolean;
};
type Audio$1 = {
    [LayerKey.audio]?: AudioOptions;
};

declare const bottom$1 = "bottom";
declare const top$1 = "top";
declare const center$1 = "center";
declare const left$1 = "left";
declare const right$1 = "right";
type LayerHorizontalAlignment = typeof center$1 | typeof left$1 | typeof right$1;
type LayerVerticalAlignment = typeof bottom$1 | typeof center$1 | typeof top$1;
declare enum PositionKey {
    angle = "angle",
    angleX = "angleX",
    angleY = "angleY",
    isRelative = "isRelative",
    origin = "origin",
    x = "x",
    y = "y",
    z = "z"
}
type X = number | LayerHorizontalAlignment;
type Y = number | LayerVerticalAlignment;
type PositionOptions = {
    [PositionKey.angle]?: number;
    [PositionKey.angleX]?: number;
    [PositionKey.angleY]?: number;
    [PositionKey.isRelative]?: boolean;
    [PositionKey.origin]?: string;
    [PositionKey.x]?: X;
    [PositionKey.y]?: Y;
    [PositionKey.z]?: number;
};
type Position = {
    [LayerKey.position]?: PositionOptions;
};

declare const fill = "fill";
declare const fit = "fit";
declare const stretch = "stretch";
type Format = typeof fill | typeof fit | typeof stretch;
declare enum SizeKey {
    format = "format",
    height = "height",
    scale = "scale",
    width = "width"
}
type SizeOptions = {
    [SizeKey.format]?: Format;
    [SizeKey.height]?: number;
    [SizeKey.scale]?: number;
    [SizeKey.width]?: number;
};
type Size = {
    [LayerKey.size]?: SizeOptions;
};

declare enum TimelineKey {
    start = "start"
}
type TimelineOptions = {
    [TimelineKey.start]?: number;
};
type Timeline = {
    [LayerKey.timeline]?: TimelineOptions;
};

declare const crossfadeIn = "crossfadeIn";
declare const crossfadeOut = "crossfadeOut";
declare const fadeIn = "fadeIn";
declare const fadeOut = "fadeOut";
declare const kenBurns = "kenBurns";
declare const angle = "angle";
declare const angleX = "angleX";
declare const angleY = "angleY";
declare const scale = "scale";
declare const x = "x";
declare const y = "y";
type TransitionTypes = typeof crossfadeIn | typeof crossfadeOut | typeof fadeIn | typeof fadeOut | typeof kenBurns | typeof angle | typeof angleX | typeof angleY | typeof scale | typeof x | typeof y;
interface TransitionFadeOptions {
    duration: number;
}
interface TransitionKenBurnsOptions {
    end: number;
    scale1: number;
    scale2: number;
    start: number;
    x1: number;
    x2: number;
    y1: number;
    y2: number;
}
interface TransitionParameterOptions {
    easing?: EasingTypes;
    easingParameter?: number;
    time: number;
    value: number;
}
interface TransitionsToOptions {
    [crossfadeIn]: TransitionFadeOptions;
    [crossfadeOut]: TransitionFadeOptions;
    [fadeIn]: TransitionFadeOptions;
    [fadeOut]: TransitionFadeOptions;
    [kenBurns]: TransitionKenBurnsOptions;
    [PositionKey.angle]: TransitionParameterOptions;
    [PositionKey.angleX]: TransitionParameterOptions;
    [PositionKey.angleY]: TransitionParameterOptions;
    [SizeKey.scale]: TransitionParameterOptions;
    [PositionKey.x]: TransitionParameterOptions;
    [PositionKey.y]: TransitionParameterOptions;
}
declare enum TransitionKey {
    duration = "duration",
    options = "options",
    type = "type"
}
type TransitionOptions = {
    [TransitionKey.options]: TransitionFadeOptions | TransitionKenBurnsOptions | TransitionParameterOptions;
    [TransitionKey.type]: TransitionTypes;
};
type Transitions = {
    [LayerKey.transitions]?: TransitionOptions[];
};
declare const easeIn = "easeIn";
declare const easeInOut = "easeInOut";
declare const easeOut = "easeOut";
declare const elasticIn = "elasticIn";
declare const elasticInOut = "elasticInOut";
declare const elasticOut = "elasticOut";
type EasingTypes = typeof easeIn | typeof easeInOut | typeof easeOut | typeof elasticIn | typeof elasticInOut | typeof elasticOut;

declare enum TrimKey {
    end = "end",
    start = "start"
}
type TrimOptions = {
    [TrimKey.end]?: number;
    [TrimKey.start]?: number;
};
type Trim = {
    [LayerKey.trim]?: TrimOptions;
};
type LayerConfigChildKey = AudioKey | PositionKey | SizeKey | TimelineKey | TransitionKey | TrimKey;

declare const normalize = "normalize";
type EffectNames = typeof normalize;
declare enum EffectOptionKey {
    normalize = "normalize"
}
interface EffectNormalize {
    [EffectOptionKey.normalize]: boolean;
}
interface Effects {
    [normalize]: EffectNormalize;
}
declare enum EffectKey {
    name = "name",
    options = "options"
}
type EffectOptions = {
    [EffectKey.name]: EffectNames;
    [EffectKey.options]?: EffectNormalize;
};

declare const brightness = "brightness";
declare const contrast = "contrast";
declare const grayscale = "grayscale";
declare const lighten = "lighten";
declare const negative = "negative";
declare const saturation = "saturation";
type FilterNames = typeof brightness | typeof contrast | typeof grayscale | typeof lighten | typeof negative | typeof saturation;
declare enum FilterOptionKey {
    brightness = "brightness",
    contrast = "contrast",
    grayscale = "grayscale",
    saturation = "saturation"
}
interface FilterBrightness {
    [FilterOptionKey.brightness]: number;
}
interface FilterContrast {
    [FilterOptionKey.contrast]: number;
}
interface FilterSaturation {
    [FilterOptionKey.saturation]: number;
}
interface FilterGrayscale {
    [FilterOptionKey.grayscale]: number;
}
interface Filters {
    [brightness]: FilterBrightness;
    [contrast]: FilterContrast;
    [grayscale]: FilterGrayscale;
    [lighten]: undefined;
    [negative]: undefined;
    [saturation]: FilterSaturation;
}
declare enum FilterKey {
    name = "name",
    options = "options"
}
type FilterOptions = {
    [FilterKey.name]: FilterNames;
    [FilterKey.options]?: FilterBrightness | FilterContrast | FilterSaturation | FilterGrayscale;
};

declare enum HtmlKey {
    page = "page",
    selector = "selector",
    url = "url",
    withTailwind = "withTailwind",
    withTransparentBackground = "withTransparentBackground",
    framesDirectory = "framesDirectory",
    framesCount = "framesCount"
}
declare enum HtmlPageKey {
    body = "body",
    styles = "styles"
}
type HtmlPage = {
    [HtmlPageKey.body]: string;
    [HtmlPageKey.styles]?: string;
};
type HtmlOptions = {
    [HtmlKey.page]?: HtmlPage;
    [HtmlKey.selector]?: string;
    [HtmlKey.url]?: string;
    [HtmlKey.withTailwind]?: boolean;
    [HtmlKey.withTransparentBackground]?: boolean;
    [HtmlKey.framesDirectory]?: string;
    [HtmlKey.framesCount]?: number;
};

interface LottieFont$1 {
    ascent: number;
    fFamily: string;
    fName: string;
    fStyle: string;
}
interface LottieAnimationFontData$1 {
    list: [LottieFont$1];
}
declare enum LottieKey {
    assets = "assets",
    ddd = "ddd",
    fonts = "fonts",
    fr = "fr",
    h = "h",
    ip = "ip",
    layers = "layers",
    markers = "markers",
    meta = "meta",
    nm = "nm",
    op = "op",
    v = "v",
    w = "w"
}
interface LottieOptions {
    [LottieKey.assets]: any[];
    [LottieKey.ddd]: number;
    [LottieKey.fonts]?: LottieAnimationFontData$1;
    [LottieKey.fr]: number;
    [LottieKey.h]: number;
    [LottieKey.ip]: number;
    [LottieKey.layers]: any[];
    [LottieKey.markers]?: any[];
    [LottieKey.meta]?: Record<string, any>;
    [LottieKey.nm]: string;
    [LottieKey.op]: number;
    [LottieKey.v]: string;
    [LottieKey.w]: number;
}

declare enum SubtitlesKey {
    backgroundColor = "backgroundColor",
    color = "color",
    fontSize = "fontSize"
}
type SubtitlesOptions = {
    [SubtitlesKey.backgroundColor]?: string;
    [SubtitlesKey.color]?: string;
    [SubtitlesKey.fontSize]?: number;
};
declare const bottom = "bottom";
declare const center = "center";
declare const justify = "justify";
declare const left = "left";
declare const right = "right";
declare const top = "top";
type TextAlign = typeof center | typeof justify | typeof left | typeof right;
type TextHorizontalPosition = typeof center | typeof left | typeof right;
type TextVerticalPosition = typeof bottom | typeof center | typeof top;
type TextPosition = {
    x?: TextHorizontalPosition;
    y?: TextVerticalPosition;
};
declare const bold = "bold";
declare const italic = "italic";
declare const normal = "normal";
type FontWeight = typeof normal | typeof bold | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
type FontStyle = typeof normal | typeof italic;
declare enum TextKey {
    backgroundColor = "backgroundColor",
    backgroundTransform = "backgroundTransform",
    border = "border",
    borderRadius = "borderRadius",
    color = "color",
    fontFamily = "fontFamily",
    fontSize = "fontSize",
    fontStyle = "fontStyle",
    fontWeight = "fontWeight",
    lineHeight = "lineHeight",
    padding = "padding",
    tailwind = "tailwind",
    text = "text",
    textAlign = "textAlign",
    textDecoration = "textDecoration",
    textPosition = "textPosition",
    textTransform = "textTransform",
    textStroke = "textStroke",
    textFillColor = "textFillColor",
    textShadow = "textShadow"
}
type TextOptions = {
    [TextKey.backgroundColor]?: string;
    [TextKey.backgroundTransform]?: string;
    [TextKey.border]?: string;
    [TextKey.borderRadius]?: number;
    [TextKey.color]?: string;
    [TextKey.fontFamily]?: string;
    [TextKey.fontSize]?: number;
    [TextKey.fontStyle]?: FontStyle;
    [TextKey.fontWeight]?: FontWeight;
    [TextKey.lineHeight]?: number;
    [TextKey.padding]?: number;
    [TextKey.tailwind]?: string;
    [TextKey.text]: string;
    [TextKey.textAlign]?: TextAlign;
    [TextKey.textDecoration]?: string;
    [TextKey.textPosition]?: TextPosition;
    [TextKey.textTransform]?: string;
    [TextKey.textStroke]?: {
        color: string;
        width: number;
    };
    [TextKey.textFillColor]?: string;
    [TextKey.textShadow]?: string;
};

declare const bars = "bars";
declare const barsVertical = "barsVertical";
declare const bricks = "bricks";
declare const curve = "curve";
declare const equalizer = "equalizer";
declare const line = "line";
declare const pixel = "pixel";
declare const roundBars = "roundBars";
declare const wave = "wave";
declare const waveSmooth = "waveSmooth";
type WaveformStyle = typeof bars | typeof barsVertical | typeof bricks | typeof curve | typeof equalizer | typeof line | typeof pixel | typeof roundBars | typeof wave | typeof waveSmooth;
declare enum WaveformKey {
    backgroundColor = "backgroundColor",
    color = "color",
    secondaryColor = "secondaryColor",
    data = "data",
    style = "style",
    numberOfFrames = "numberOfFrames",
    waveforms = "waveforms"
}
type WaveformOptions = {
    [WaveformKey.backgroundColor]?: string;
    [WaveformKey.secondaryColor]?: string;
    [WaveformKey.style]?: WaveformStyle;
    [WaveformKey.color]?: string;
};

declare enum LayerKey {
    audio = "audio",
    filter = "filter",
    effect = "effect",
    html = "html",
    id = "id",
    lottie = "lottie",
    position = "position",
    size = "size",
    subtitles = "subtitles",
    source = "source",
    text = "text",
    timeline = "timeline",
    transitions = "transitions",
    trim = "trim",
    type = "type",
    waveform = "waveform",
    wordCount = "wordCount"
}
declare enum LayerType {
    audio = "audio",
    effect = "effect",
    filter = "filter",
    group = "group",
    html = "html",
    image = "image",
    lottie = "lottie",
    sequence = "sequence",
    subtitles = "subtitles",
    text = "text",
    video = "video",
    waveform = "waveform"
}
type AudioLayerConfig = Audio$1 & Timeline & Transitions & Trim;
type AudioLayer = AudioLayerConfig;
type FilterNamespace = {
    [LayerKey.filter]: FilterOptions;
};
type FilterLayer = FilterNamespace;
type EffectNamespace = {
    [LayerKey.effect]: EffectOptions;
};
type EffectLayer = EffectNamespace;
type HtmlLayerConfig = Position & Size & Timeline & Transitions & Trim;
type HtmlNamespace = {
    [LayerKey.html]: HtmlOptions;
};
type HtmlLayer = HtmlLayerConfig & HtmlNamespace;
type ImageLayerConfig = Position & Size & Timeline & Transitions & Trim;
type ImageLayer = ImageLayerConfig;
type LottieLayerConfig = Position & Size & Timeline & Transitions & Trim;
type LottieNamespace = {
    [LayerKey.lottie]: LottieOptions;
};
type LottieLayer = LottieLayerConfig & LottieNamespace;
type GroupLayerConfig = Audio$1 & Position & Size & Timeline & Transitions & Trim;
type GroupLayer = GroupLayerConfig;
type SequenceLayerConfig = Timeline;
type SubtitlesLayerConfig = Position & Timeline & Transitions & Trim;
type SubtitlesNamespace = {
    [LayerKey.subtitles]: SubtitlesOptions;
    [LayerKey.source]: string;
    [LayerKey.wordCount]?: number;
};
type SubtitlesLayer = SubtitlesLayerConfig & SubtitlesNamespace;
type TextLayerConfig = Position & Size & Timeline & Transitions & Trim;
type TextNamespace = {
    [LayerKey.text]: TextOptions;
};
type TextLayer = TextLayerConfig & TextNamespace;
type VideoLayerConfig = Audio$1 & Position & Size & Timeline & Transitions & Trim;
type VideoLayer = VideoLayerConfig;
type WaveformLayerConfig = Position & Size & Timeline & Transitions & Trim;
type WaveformNamespace = {
    [LayerKey.waveform]: WaveformOptions;
};
type WaveformLayer = WaveformLayerConfig & WaveformNamespace;
type ComposableLayer = AudioLayer | FilterLayer | EffectLayer | HtmlLayer | GroupLayer | ImageLayer | LottieLayer | SubtitlesLayer | TextLayer | VideoLayer | WaveformLayer;
type TypedLayer = ComposableLayer & {
    type: LayerType;
};
type IdentifiedLayer = TypedLayer & {
    file?: string | Readable$1;
    id: string;
    assetId?: string;
};
type LayerChildKey = AudioKey | EffectKey | FilterKey | HtmlKey | SubtitlesKey | TextKey | WaveformKey;
type ChildKey = LayerChildKey | LayerConfigChildKey;

declare enum CompositionKey {
    backgroundColor = "backgroundColor",
    dimensions = "dimensions",
    duration = "duration",
    extension = "extension",
    filename = "filename",
    files = "files",
    fps = "fps",
    layers = "layers",
    metadata = "metadata",
    thumbnail = "thumbnail"
}
type CompositionFile = Readable | Blob | string;
declare enum VideoExtensions {
    mov = "mov",
    mp4 = "mp4",
    webm = "webm"
}

interface ApiInterface {
    get: ({ url }: {
        url: string;
    }) => Promise<unknown>;
    post: ({ data, isForm, url, }: {
        data: FormData | Record<string, any> | string;
        isForm: boolean;
        url: string;
    }) => Promise<unknown>;
    put: ({ data, isForm, url, }: {
        data: FormData | Record<string, any> | string;
        isForm: boolean;
        url: string;
    }) => Promise<unknown>;
}
interface FormDataInterface {
    append: (key: string, value: any, options?: FormData.AppendOptions | string) => void;
}

type Hashided = {
    id: string;
};
type Timestamped = {
    createdAt: string;
    updatedAt: string;
};

declare enum ApiApplicationKey {
    description = "description",
    id = "id",
    name = "name",
    webhook = "webhook"
}
type ApiApplication = Hashided & Timestamped & {
    [ApiApplicationKey.description]: string;
    [ApiApplicationKey.name]: string;
    [ApiApplicationKey.webhook]: string;
};

interface EditframeOptions {
    develop?: boolean;
    host?: string;
    log?: boolean;
    token?: string;
    version?: number;
}

declare enum ApiFlowKey {
    id = "id",
    isFailed = "isFailed",
    isReady = "isReady",
    metadata = "metadata",
    timestamp = "timestamp",
    deliverables = "deliverables",
    jobs = "jobs",
    status = "status"
}
declare enum ApiFlowDeliverablesKey {
    zip = "zip",
    filename = "filename"
}
declare enum ApiFlowJobsKey {
    template = "template",
    type = "type",
    id = "id",
    inputs = "inputs",
    filename = "filename",
    metadata = "metadata"
}
type ApiFlow = Hashided & {
    [ApiFlowKey.isFailed]: boolean;
    [ApiFlowKey.isReady]: boolean;
    [ApiFlowKey.timestamp]: number;
};
type FlowEncodeOptions = {
    [ApiFlowKey.id]: string;
    [ApiFlowKey.status]: string;
    [ApiFlowKey.timestamp]: number;
};
type FlowOptions = {
    [ApiFlowKey.jobs]?: FlowJobs[];
    [ApiFlowKey.deliverables]: FlowDeliverables;
};
type FlowDeliverables = {
    [ApiFlowDeliverablesKey.zip]: {
        [ApiFlowDeliverablesKey.filename]: string;
    };
};
type FlowJobs = {
    [ApiFlowJobsKey.type]: string;
    [ApiFlowJobsKey.template]: {
        [ApiFlowJobsKey.id]: string;
        [ApiFlowJobsKey.inputs]: Record<string, any>;
        [ApiFlowJobsKey.filename]: string;
    };
    [ApiFlowJobsKey.metadata]: Record<string, any>;
};
declare enum ApiFlowMethod {
    all = "all",
    get = "get",
    new = "new"
}
interface FlowInterface {
    [ApiFlowKey.jobs]: FlowJobs[];
    [ApiFlowKey.deliverables]: FlowDeliverables;
}
declare enum FlowMethod {
    addJob = "addJob",
    new = "new",
    run = "run",
    extension = "extension",
    deliverables = "deliverables",
    jobs = "jobs"
}

declare enum LottieMethod {
    setAnimationData = "setAnimationData"
}
interface LottieFont {
    ascent: number;
    fFamily: string;
    fName: string;
    fStyle: string;
}
interface LottieAnimationFontData {
    list: [LottieFont];
}
interface LottieAnimationData {
    assets: any[];
    ddd: number;
    fonts?: LottieAnimationFontData;
    fr: number;
    h: number;
    ip: number;
    layers: any[];
    markers?: any[];
    nm: string;
    op: number;
    v: string;
    w: number;
}

type LayerAttributeValue = boolean | number | string | FilterOptions | EffectOptions | HtmlOptions | HtmlPage | LottieAnimationData | Readable$1 | SubtitlesOptions | TransitionOptions[] | TextPosition;
declare enum CompositionMethod {
    addAudio = "addAudio",
    addFilter = "addFilter",
    addEffect = "addEffect",
    addGroup = "addGroup",
    addHtml = "addHtml",
    addImage = "addImage",
    addLottie = "addLottie",
    addSequence = "addSequence",
    addSubtitles = "addSubtitles",
    addText = "addText",
    addVideo = "addVideo",
    addWaveform = "addWaveform",
    aspectRatio = "_aspectRatio",
    backgroundColor = "backgroundColor",
    dimensions = "dimensions",
    duration = "duration",
    encode = "encode",
    encodeSync = "encodeSync",
    extension = "extension",
    getLayerAttribute = "getLayerAttribute",
    getMetadata = "_getMetadata",
    identifiedLayers = "identifiedLayers",
    layer = "layer",
    metadata = "metadata",
    preview = "preview",
    setDuration = "_setDuration",
    setFile = "_setFile",
    setLayer = "setLayer",
    setLayerAttribute = "setLayerAttribute"
}
interface CompositionInterface {
    readonly [CompositionMethod.duration]: number;
    [CompositionMethod.layer]: (id: string) => IdentifiedLayer;
    [CompositionMethod.identifiedLayers]: IdentifiedLayer[];
    [CompositionMethod.getLayerAttribute]: <LayerAttributeValue>({ childKey, id, layerKey, }: {
        childKey?: ChildKey;
        id: string;
        layerKey: LayerKey;
    }) => LayerAttributeValue;
    [CompositionMethod.setLayerAttribute]: ({ childKey, id, layerKey, value, }: {
        childKey?: ChildKey;
        id: string;
        layerKey: LayerKey;
        value: LayerAttributeValue;
    }) => void;
}
type Metadata = Record<string, JsonValue>;
type VideoOptions = {
    [CompositionKey.backgroundColor]?: string;
    [CompositionKey.dimensions]?: Dimensions;
    [CompositionKey.filename]?: string;
    [CompositionKey.duration]?: number;
    [CompositionKey.extension]?: VideoExtensions;
    [CompositionKey.fps]?: number;
    [CompositionKey.metadata]?: Metadata;
};
type CompositionOptions = {
    [CompositionKey.backgroundColor]?: string;
    [CompositionKey.dimensions]: Dimensions;
    [CompositionKey.duration]?: number;
    [CompositionKey.extension]?: VideoExtensions;
    [CompositionKey.fps]?: number;
    [CompositionKey.filename]?: string;
    [CompositionKey.metadata]?: Metadata;
};
declare enum EncodeResponseKey {
    id = "id",
    status = "status",
    timestamp = "timestamp"
}
type EncodeOptions = {
    experimental?: {
        renderingEngine: 'v2-beta';
    };
};
type EncodeResponse = {
    [EncodeResponseKey.id]: string;
    [EncodeResponseKey.status]: string;
    [EncodeResponseKey.timestamp]: number;
};
type ExportableConfig = CompositionOptions & {
    layers: ComposableLayer[];
};

declare enum AudioMethod {
    setVolume = "setVolume"
}

declare enum EffectMethod {
    setEffect = "setEffect"
}

declare enum FilterMethod {
    setFilter = "setFilter"
}

declare class Layer {
    protected _composition: CompositionInterface;
    private _id;
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get id(): string;
    getAttribute<Value>({ childKey, layerKey }: {
        childKey?: ChildKey;
        layerKey: LayerKey;
    }): Value;
    setAttribute({ childKey, layerKey, value, }: {
        childKey?: ChildKey;
        layerKey: LayerKey;
        value: LayerAttributeValue;
    }): this;
}

declare class AudioMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get volume(): number | undefined;
    [AudioMethod.setVolume](volume?: number): this;
    setMuted(): this;
    private _getAudioAttribute;
    private _setAudioAttribute;
}

declare class TimelineMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get timeline(): TimelineOptions;
    get start(): number;
    [TimelineMethod.setStart](start?: number): this;
    private _getTimelineAttribute;
    private _setTimelineAttribute;
}

declare class TransitionsMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get transitions(): TransitionOptions[];
    [TransitionsMethod.addTransition]<TransitionType extends keyof TransitionsToOptions>({ options, type, }: {
        options: TransitionsToOptions[TransitionType];
        type: TransitionTypes;
    }): this;
    [TransitionsMethod.setTransitions](transitions: TransitionOptions[]): this;
}

declare class TrimMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get trim(): TrimOptions;
    [TrimMethod.setTrim](start?: number, end?: number): this;
    private _setTrimAttribute;
}

declare const Audio_base: ts_mixer_dist_types_types.Class<any[], AudioMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof AudioMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Audio extends Audio_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
}

declare class PositionMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get angle(): number;
    get angleX(): number;
    get angleY(): number;
    get isRelative(): boolean | undefined;
    get origin(): string;
    get x(): X | undefined;
    get y(): Y | undefined;
    get z(): number | undefined;
    [PositionMethod.setAngle](angle?: number): this;
    [PositionMethod.setAngleX](angleX?: number): this;
    [PositionMethod.setAngleY](angleY?: number): this;
    [PositionMethod.setIsRelative](isRelative?: boolean): this;
    [PositionMethod.setX](x?: X): this;
    [PositionMethod.setOrigin](origin: string): this;
    [PositionMethod.setY](y?: Y): this;
    [PositionMethod.setZ](z?: number): this;
    private _getPositionAttribute;
    private _setPositionAttribute;
}

declare class SizeMixin extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get dimensions(): Omit<SizeOptions, SizeKey.format>;
    get format(): Format;
    get height(): number;
    get scale(): number;
    get width(): number;
    [SizeMethod.setDimensions]({ height, width }: Dimensions): this;
    [SizeMethod.setFormat](format: Format): this;
    [SizeMethod.setHeight](height?: number): this;
    [SizeMethod.setScale](scale?: number): this;
    [SizeMethod.setWidth](width?: number): this;
    private _getSizeAttribute;
    private _setSizeAttribute;
}

declare const Html_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Html extends Html_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get page(): HtmlPage | undefined;
    get url(): string | undefined;
    get withTailwind(): boolean;
    get withTransparentBackground(): boolean;
    [HtmlMethod.setPage](page?: HtmlPage): Promise<this>;
    [HtmlMethod.setUrl](url?: string): this;
    [HtmlMethod.setWithTailwind](withTailwind: boolean): this;
    [HtmlMethod.setWithTransparentBackground](withTransparentBackground: boolean): this;
    private _getHtmlAttribute;
    private setHtmlAttribute;
}

declare const Image_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Image extends Image_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
}

declare const Lottie_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Lottie extends Lottie_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get animationData(): LottieAnimationData;
    [LottieMethod.setAnimationData](data: LottieAnimationData): Lottie;
}

declare const Subtitles_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Subtitles extends Subtitles_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get backgroundColor(): string | undefined;
    get color(): string | undefined;
    get fontSize(): number | undefined;
    [SubtitlesMethod.setBackgroundColor](color?: string): this;
    [SubtitlesMethod.setColor](color?: string): this;
    [SubtitlesMethod.setFontSize](size?: number): this;
    private _getSubtitlesAttribute;
    private _setSubtitlesAttribute;
}

declare const Text_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Text extends Text_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get backgroundColor(): string;
    get backgroundTransform(): string;
    get border(): string;
    get borderRadius(): number;
    get color(): string | undefined;
    get fontFamily(): string | undefined;
    get fontSize(): string;
    get fontStyle(): FontStyle;
    get fontWeight(): FontWeight;
    get lineHeight(): number;
    get padding(): number;
    get text(): string;
    get textAlign(): TextAlign;
    get textDecoration(): string;
    get textPosition(): TextPosition;
    get textTransform(): string;
    get tailwind(): string;
    [TextMethod.setBackgroundColor](backgroundColor: string): this;
    [TextMethod.setBackgroundTransform](backgroundTransform: string): this;
    [TextMethod.setBorder](border: string): this;
    [TextMethod.setBorderRadius](borderRadius: number): this;
    [TextMethod.setColor](color: string): this;
    [TextMethod.setFontFamily](fontFamily: string): this;
    [TextMethod.setFontSize](fontSize: number): this;
    [TextMethod.setFontStyle](fontStyle: FontStyle): this;
    [TextMethod.setFontWeight](fontWeight: FontWeight): this;
    [TextMethod.setLineHeight](lineHeight?: number): this;
    [TextMethod.setPadding](padding: number): this;
    [TextMethod.setText](text: string): this;
    [TextMethod.setTextAlign](textAlign: TextAlign): this;
    [TextMethod.setTextDecoration](textDecoration: string): this;
    [TextMethod.setTextPosition](textPosition: {
        x: TextHorizontalPosition;
        y: TextVerticalPosition;
    }): this;
    [TextMethod.setTextTransform](textTransform: string): this;
    private _getTextAttribute;
    private _setTextAttribute;
}

declare const Video_base: ts_mixer_dist_types_types.Class<any[], AudioMixin & PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof AudioMixin & typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Video extends Video_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
}

declare const Waveform_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Waveform extends Waveform_base {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get backgroundColor(): string | undefined;
    get color(): string | undefined;
    get style(): WaveformStyle | undefined;
    [WaveformMethod.setBackgroundColor](color?: string): this;
    [WaveformMethod.setColor](color?: string): this;
    [WaveformMethod.setStyle](style?: WaveformStyle): this;
    private _getWaveformAttribute;
    private _setWaveformAttribute;
}

declare enum GroupMethod {
    setStart = "setStart"
}
type GroupableLayer = Audio | Html | Image | Lottie | Subtitles | Text | Video | Waveform;

declare enum HtmlMethod {
    setHtmlOptions = "setHtmlOptions",
    setPage = "setPage",
    setUrl = "setUrl",
    setWithTailwind = "setWithTailwind",
    setWithTransparentBackground = "setWithTransparentBackground"
}

declare const Group_base: ts_mixer_dist_types_types.Class<any[], PositionMixin & SizeMixin & TimelineMixin & TransitionsMixin & TrimMixin, typeof PositionMixin & typeof SizeMixin & typeof TimelineMixin & typeof TransitionsMixin & typeof TrimMixin, false>;
declare class Group extends Group_base {
    layers: (Audio | Html | Image | Lottie | Subtitles | Text | Video | Waveform)[];
    constructor({ composition, id, layers, }: {
        composition: CompositionInterface;
        id: string;
        layers: (Audio | Html | Image | Lottie | Subtitles | Text | Video | Waveform)[];
    });
    get type(): LayerType;
    [GroupMethod.setStart](start?: number): this;
}

declare enum SequenceMethod {
    setStart = "setStart"
}
type SequenceableLayer = Audio | Group | Html | Image | Lottie | Subtitles | Text | Video | Waveform;

declare enum SubtitlesMethod {
    setBackgroundColor = "setBackgroundColor",
    setColor = "setColor",
    setFontSize = "setFontSize",
    setSubtitlesOptions = "setSubtitlesOptions"
}

declare enum TextMethod {
    setBackgroundColor = "setBackgroundColor",
    setBackgroundTransform = "setBackgroundTransform",
    setBorder = "setBorder",
    setBorderRadius = "setBorderRadius",
    setColor = "setColor",
    setFontFamily = "setFontFamily",
    setFontSize = "setFontSize",
    setFontStyle = "setFontStyle",
    setFontWeight = "setFontWeight",
    setLineHeight = "setLineHeight",
    setPadding = "setPadding",
    setText = "setText",
    setTextAlign = "setTextAlign",
    setTextDecoration = "setTextDecoration",
    setTextPosition = "setTextPosition",
    setTextTransform = "setTextTransform"
}

declare enum WaveformMethod {
    setBackgroundColor = "setBackgroundColor",
    setColor = "setColor",
    setStyle = "setStyle"
}

declare enum PositionMethod {
    setAngle = "setAngle",
    setAngleX = "setAngleX",
    setAngleY = "setAngleY",
    setIsRelative = "setIsRelative",
    setOrigin = "setOrigin",
    setX = "setX",
    setY = "setY",
    setZ = "setZ"
}

declare enum SizeMethod {
    setDimensions = "setDimensions",
    setFormat = "setFormat",
    setHeight = "setHeight",
    setScale = "setScale",
    setWidth = "setWidth"
}

declare enum TimelineMethod {
    setStart = "setStart"
}

declare enum TransitionsMethod {
    addTransition = "addTransition",
    setTransitions = "setTransitions"
}

declare enum TrimMethod {
    setTrim = "setTrim"
}

declare enum ApiVideoKey {
    downloadUrl = "downloadUrl",
    duration = "duration",
    id = "id",
    isFailed = "isFailed",
    isReady = "isReady",
    metadata = "metadata",
    streamUrl = "streamUrl",
    thumbnailUrl = "thumbnailUrl",
    timestamp = "timestamp"
}
type ApiVideo = Hashided & {
    [ApiVideoKey.downloadUrl]?: string;
    [ApiVideoKey.duration]?: number;
    [ApiVideoKey.isFailed]: boolean;
    [ApiVideoKey.isReady]: boolean;
    [ApiVideoKey.metadata]: Record<string, any>;
    [ApiVideoKey.streamUrl]?: string;
    [ApiVideoKey.thumbnailUrl]?: string;
    [ApiVideoKey.timestamp]: number;
};
declare enum ApiVideoMethod {
    all = "all",
    get = "get",
    getMetadata = "_getMetadata",
    new = "new"
}

declare class Applications {
    private _api;
    constructor(api: ApiInterface);
    all(page?: number, perPage?: number): Promise<ApiApplication[]>;
    get(id: string): Promise<ApiApplication | undefined>;
}

declare class Flow implements FlowInterface {
    private _api;
    private _develop;
    jobs: FlowJobs[];
    deliverables: FlowDeliverables;
    constructor({ api, deliverables, develop, jobs, }: {
        api: ApiInterface;
        host: string;
        jobs?: FlowJobs[];
        deliverables: FlowDeliverables;
        develop: boolean;
    });
    [FlowMethod.addJob](job: FlowJobs): FlowJobs[];
    [FlowMethod.run](): Promise<FlowEncodeOptions>;
}

declare class Flows {
    private _api;
    private _host;
    private _develop;
    constructor({ api, develop, host }: {
        api: ApiInterface;
        develop?: boolean;
        host: string;
    });
    [ApiFlowMethod.all](page?: number, perPage?: number): Promise<ApiFlow[]>;
    [ApiFlowMethod.get]({ id }: {
        id: string;
    }): Promise<ApiFlow | undefined>;
    [ApiFlowMethod.new](options: FlowOptions): Promise<Flow>;
}

declare class Effect extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get name(): string;
    get options(): EffectOptions[EffectKey.options];
    [EffectMethod.setEffect]<EffectName extends keyof Effects>({ name, options, }: {
        name: EffectName;
        options?: Effects[EffectName];
    }): this;
    private _getEffectAttribute;
}

declare class Filter extends Layer {
    constructor({ composition, id }: {
        composition: CompositionInterface;
        id: string;
    });
    get type(): LayerType;
    get name(): string;
    get options(): FilterOptions[FilterKey.options];
    [FilterMethod.setFilter]<FilterName extends keyof Filters>({ name, options, }: {
        name: FilterName;
        options?: Filters[FilterName];
    }): this;
    private _getFilterAttribute;
}

declare const Sequence_base: ts_mixer_dist_types_types.Class<any[], TimelineMixin, typeof TimelineMixin, false>;
declare class Sequence extends Sequence_base {
    layers: (Audio | Group | Html | Image | Lottie | Subtitles | Text | Video | Waveform)[];
    constructor({ composition, id, layers, }: {
        composition: CompositionInterface;
        id: string;
        layers: (Audio | Html | Image | Lottie | Subtitles | Text | Video | Waveform)[];
    });
    get type(): LayerType;
    [SequenceMethod.setStart](start?: number): this;
}

declare class Composition implements CompositionInterface {
    private _api;
    private _develop;
    private _encodeOptions?;
    private _files;
    private _formData;
    private _host;
    layers: IdentifiedLayer[];
    private _identifiedLayers;
    private _options;
    private _temporaryDirectory;
    private _videos;
    constructor({ api, develop, formData, host, options, temporaryDirectory, videos, }: {
        api: ApiInterface;
        develop?: boolean;
        formData: FormDataInterface;
        host: string;
        options: CompositionOptions;
        temporaryDirectory?: string;
        videos: Videos;
    });
    get [CompositionMethod.backgroundColor](): string;
    get [CompositionMethod.dimensions](): Dimensions;
    get [CompositionMethod.duration](): number;
    get [CompositionMethod.extension](): VideoExtensions;
    get [CompositionMethod.metadata](): Metadata;
    get [CompositionMethod.identifiedLayers](): IdentifiedLayer[];
    addLayer(layer: IdentifiedLayer): void;
    [CompositionMethod.layer](id: string): IdentifiedLayer;
    [CompositionMethod.getLayerAttribute]<AttributeValue>({ childKey, id, layerKey, }: {
        childKey?: ChildKey;
        id: string;
        layerKey: LayerKey;
    }): AttributeValue;
    [CompositionMethod.setLayerAttribute]({ childKey, id, layerKey, value, }: {
        childKey?: ChildKey;
        id: string;
        layerKey: LayerKey;
        value: LayerAttributeValue;
    }): void;
    [CompositionMethod.addAudio](file: CompositionFile, options?: AudioOptions, layerConfig?: AudioLayerConfig): Promise<Audio>;
    [CompositionMethod.addFilter]<FilterName extends keyof Filters>(options: {
        name: FilterName;
        options?: Filters[FilterName];
    }): Filter | undefined;
    [CompositionMethod.addEffect]<EffectName extends keyof Effects>(options: {
        name: EffectName;
        options?: Effects[EffectName];
    }): Effect | undefined;
    [CompositionMethod.addGroup](layers: GroupableLayer[], layerConfig: GroupLayerConfig): Group;
    [CompositionMethod.addHtml](options: HtmlOptions, layerConfig?: HtmlLayerConfig): Promise<Html>;
    [CompositionMethod.addImage](file: CompositionFile, layerConfig?: ImageLayerConfig): Promise<Image>;
    [CompositionMethod.addLottie](options: LottieOptions, layerConfig?: LottieLayerConfig): Lottie | undefined;
    [CompositionMethod.addSequence](layers: SequenceableLayer[], layerConfig?: SequenceLayerConfig): Promise<Sequence>;
    [CompositionMethod.addSubtitles](file: CompositionFile, options?: SubtitlesOptions, layerConfig?: SubtitlesLayerConfig): Promise<Subtitles>;
    [CompositionMethod.addText](options: TextOptions, layerConfig?: TextLayerConfig): Text | undefined;
    [CompositionMethod.addVideo](file: CompositionFile, layerConfig?: VideoLayerConfig): Promise<Video>;
    [CompositionMethod.addWaveform](file?: CompositionFile, options?: WaveformOptions, layerConfig?: WaveformLayerConfig): Promise<Waveform>;
    [CompositionMethod.encode](encodeOptions?: EncodeOptions): Promise<EncodeResponse>;
    [CompositionMethod.encodeSync](encodeOptions?: EncodeOptions): Promise<ApiVideo>;
    [CompositionMethod.preview](): Promise<void>;
    private _addIdentifiedLayer;
    private _processDynamicTransitions;
    generateConfig(asString?: boolean): string | ExportableConfig;
    private prepareFormData;
    private _nonUtilLayers;
    private [CompositionMethod.getMetadata];
    private _file;
    private [CompositionMethod.setDuration];
    private [CompositionMethod.setFile];
    private [CompositionMethod.setLayer];
    private _setLayerDefaults;
}

declare class Videos {
    private _api;
    private _develop;
    private _host;
    constructor({ api, develop, host }: {
        api: ApiInterface;
        develop?: boolean;
        host: string;
    });
    [ApiVideoMethod.all](page?: number, perPage?: number): Promise<ApiVideo[]>;
    [ApiVideoMethod.get]({ id }: {
        id: string;
    }): Promise<ApiVideo | undefined>;
    [ApiVideoMethod.new](options?: VideoOptions, videoFile?: CompositionFile): Promise<Composition>;
    private [ApiVideoMethod.getMetadata];
}

declare class Editframe {
    applications: Applications;
    videos: Videos;
    flows: Flows;
    private _api;
    private _host;
    private _token;
    private _version;
    constructor({ develop, host, token, version }: EditframeOptions);
    get host(): string;
    get token(): string;
    get version(): number;
}
declare const CommonResolutions: Record<string, Dimensions>;

export { CommonResolutions, Editframe };
